# Kafka
소스 애플리케이션과 타겟 애플리케이션의 개수가 늘어남 → 데이터 전송 라인량의 증가
커플링을 줄이기 위해 개발
고가용성, 낮은 지연, 높은 처리량 특징

### 토픽
카프카에서 데이터가 들어가는 공간
AMQP와는 다르게 동작
데이터베이스의 테이블, 파일시스템의 디렉토리

### 파티션
한 토픽에 여러 파티션을 가질 수 있음
파티션을 큐처럼 사용
메시지 키가 없으면 라운드로빈으로 파티션에 적절히 데이터를 분배해서 저장
메시지 키가 있으면 키의 해시 값으로 특정 파티션에 할당
파티션을 늘릴수는 있지만 줄일수는 없음
파티션에 저장하는 최대 시간과 크기는 옵션 값을 지정하여 설정 가능 (retention)

### 브로커(broker)
카프카가 설치되어 있는 서버 단위
보통 3개 이상의 브로커 사용을 권장
파티션 1, 레플리케이션 1, 브로커 3 → 브로커 중 한 대에 저장

레플리케이션 : 파티션의 복제
replication 2 → 파티션 원본 1, 복제본 1
replication 3 → 파티션 원본 1, 복제본 2
replication은 브로커보다 많을 수 없음
브로커 3대 → replication 최대 값 3 (추천)

원본 파티션 : Leader 파티션
복제 파티션 : Follower 파티션
Leader + Follower → ISR, In Sync Replica
카프카의 고가용성 보장

프로듀서가 토픽의 파티션에 데이터를 전달할 때 리더 파티션에 전달
ack 옵션 0, 1, all
0: 프로듀서가 리더 파티션에 데이터 전달 후 응답 X (정상적으로 전달되었는지 알 수 없음)
1: 리더 파티션이 정상적으로 받았는지 응답 O, 복제여부 X (리더파티션 장애시 데이터유실 가능성)
2: 리더 파티션, 팔로워 파티션 응답 O (유실 X, 속도 느림)

### 파티셔너(Partitioner)
데이터를 토픽 중 어떤 파티션에 넣을지 결정
UniformStickyPartitioner : default 파티셔너
메시지 키가 있는 경우 파티션의 해시로직에 의해 파티션 결정 (같은 해시의 저장 값에 대해서는 순서가 보장)
메시지 키가 없는 경우 라운드 로빈 방식으로 파티션 결정 (배치 단위)
파티셔너 인터페이스를 통해 커스텀 가능 (우선순위 큐 등을 위해)

### Consumer Lag
프로듀서가 마지막으로 넣은 offset과 컨슈머가 마지막으로 읽은 offset의 차이
주로 컨슈머의 상태를 확인하기 위해 모니터링
파티션이 여러개면 Consumer Lag도 여러개 존재

### Burrow
컨슈머 lag 모니터링을 도와주는 애플리케이션
멀티 카프카 클러스터 지원
sliding window를 통해 consumer 상태를 확인

## 메시징 플랫폼
### 메시지 브로커
대규모 메시지 기반 미들웨어 아키텍처에서 사용되어 왔음
프로듀서와 컨슈머를 통해 메시지를 통신
메시지를 받은 뒤, 적절한 처리 후 짧은 시간 내에 삭제됨
RabbitMQ, Redis Queue

### 이벤트 브로커
레코드(이벤트/메시지)를 하나만 보관, 인덱스를 통해 개별 액세스 관리
필요한 시간동안 이벤트 보존 가능
서비스에서 나온 이벤트를 큐에 저장
Kafka, AWS Kinesis



