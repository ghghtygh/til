# MySQL
#TIL/MySQL

## MySQL 엔진 아키텍처
MySQL 서버 = MySQL 엔진 + 스토리지 엔진

### MySQL 엔진
클라이언트 접속 및 쿼리 요청 처리하는 커넥션 핸들러
SQL 파서 및 전처리기
쿼리의 최적화된 실행을 위한 옵티마이저

### 스토리지 엔진
실제 데이터를 디스크 스토리지에 저장하거나 데이터를 읽어오는 부분 전담
MySQL 엔진은 하나를 사용하고 스토리지 엔진은 여러 개를 동시에 사용 가능
MyISAM 스토리지 엔진 (키 캐시)
InnoDB 스토리지 엔진 (InnoDB 버퍼 풀)

### 핸들러(Handler) API
핸들러 요청에 사용되는 API

핸들러(Handler) 요청 : MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야할 때 스토리지 엔진에 보내는 요청

``` 
# 핸들러 API 조회
mysql> SHOW GLABAL STATUS LIKE ‘Handler%’; 
```


## MySQL 스레딩 구조

![](README/C414F661-7644-46D5-B044-0AB023FA29AB.png)

### 포그라운드(Foreground) 스레드
최소 MySQL 서버에 접속된 클라이언트 수만큼 존재
각 클라이언트가 요청하는 쿼리 문장 처리
커넥션 종료시 스레드 캐시(Thread cahce)로 돌아가는데 일정 개수 이상 스레드가 있으면 종료(thread_cache_size)
MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리

### 백그라운드(Background) 스레드
인서트 버퍼를 병합
로그를 디스크로 기록
InnoDB 버퍼 풀 데이터를 디스크에 기록
데이터를 버퍼로 읽어옴
잠금이나 데드락 모니터링


## 메모리 구조
### 글로벌 메모리 영역	
	- 테이블 캐시
	- InnoDB 버퍼 풀
	- InnoDB 어댑티브 해시 인덱스
	- InnoDB 리두 로그 버퍼
클라이언트 스레드 수와 무관
모든 스레드에 의해 공유


### 로컬 메모리 영역(세션 메모리 영역)
	- 정렬 버퍼(Sort buffer)
	- 조인 버퍼
	- 바이너리 로그 캐시
	- 네트워크 버퍼
MySQL 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용
각 클라이언트 스레드별 독립적 할당, 공유되지 않음
각 쿼리의 용도별로 필요할 때만 공간이 할당될 수도 있음

### 플러그인 스토리지 엔진 모델
MySQL의 독특한 구조 중 대표적인 것
전문 검색 엔진을 위한 검색어 파서, 사용자 인증을 위한 Native Authentication 등이 플러그인으로 구현되어 제공
사용자가 직접 스토리지 엔진을 개발할 수 있음

### 컴포넌트
MySQL 8.0 이후 제공되는 아키텍처
플러그인의 단점을 개선
	- MySQL 서버만 인터페이스 가능, 플러그인끼리 통신 불가
	- MySQL 서버의 변수나 함수를 직접 호출 (캡슐화 안됨)
	- 상호 의존 관계 설정할 수 없어 초기화가 어려움


## 쿼리 실행 구조

![](README/DA27BE1F-81D4-4047-91B0-BFB82BEB849F.png)

### 쿼리 파서
사용자 요청으로 들어온 문장을 토큰으로 분리해 트리 구조로 만드는 작업
토큰 : MySQL이 인식할 수 있는 최소 단위의 어휘나 기호

### 전처리기
파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장의 문제점 여부 확인
테이블, 컬럼, 함수명 등을 매핑하여 객체 존재여부 및 접근권한 확인

### 옵티마이저
쿼리 문장을 어떻게 적은 비용으로 빠른 처리할지 결정
옵티마이저가 더 나은 선택을 하도록 유도하는 것이 필요

### 실행 엔진
만들어진 계획대로 각 핸들러에 요청한 뒤, 요청 결과를 다른 핸들러 요청의 입력으로 연결

### 핸들러(스토리지 엔진)
데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할(=스토리지 엔진)

## 쿼리 캐시(Query Cache)
SQL 실행 결과를 메모리에 캐시하고 동일한 SQL 쿼리가 실행되면 즉시 결과를 반환
데이터가 변경될 경우 캐시 결과 중 관련 데이터를 모두 삭제하는데, 이 때 동시 처리 성능 저하가 유발되었고, 성능 개선되는 과정에서 많은 버그의 원인이 되면서 MySQL 8.0에서는 제거됨

## 스레드 풀(Thread Pool)
엔터프라이즈 에디션에서는 제공하지만 커뮤니티 에디션은 지원하지 않음

### Percona Server에서 제공하는 스레드 풀
플러그인 형태로 작동
사용자 요청을 처리하는 스레드 개수를 줄여서 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있도록 자원 소모를 줄임


## InnoDB 스토리지 엔진 아키텍처
스토리지 엔진 중 유일하게 레코드 기반 잠금을 제공 -> 높은 동시성 처
리
안정적이며 성능이 뛰어남

## 인덱스
### 디스크 읽기 방식
#### HDD와 SSD


## 옵티마이저
### 쿼리 실행 절차
1. 요청된 SQL 문장을 쪼개 MySQL 서버가 이해할 수 있는 수준으로 분리 
(SQL 파서: SQL Parsing 수행 -> SQL 파스 트리 생성)
2. SQL 파싱정보를 확인하며 어떤 테이블부터 어떤 인덱스로 테이블을 읽을지 선택
(옵티마이저: 최적화 및 실행 계획 수립 -> 실행 계획 수립)
3. 2단계에서 결정된 읽기 순서 또는 선택된 인덱스로 스토리지 엔진에서 데이터를 가져옴

### 옵티마이저 종류

1. 비용 기반 최적화(Cost-based optimizer, CBO)
쿼리를 처리하기 위한 여러 가능한 방법 생성 
-> 각 단위 작업의 비용 정보와 테이블 예측 통계로 실행 게획별 비용을 산출
-> 비용이 최소로 소요되는 처리 방식으로 쿼리 실행

2. 규칙 기반 최적화(Rule-based optimizer, RBO)
옵티마이저에 내장된 우선 순위에 따라 실행 게획을 수립
테이블의 레코드 건수나 컬럼값의 분포도 조사하지 않고 수립되어, 같은 쿼리는 거의 항상 같은 실행 방법을 만듬

현재 대부분의 RDBS가 비용 기반의 옵티마이저를 채택 (MySQL 포함)

#### 기본 데이터 처리
##### 풀 테이블 스캔

## 실행 계획
### 통계정보
MySQL 5.7 까지는 테이블과 인덱스에 대한 개괄적인 정보로 실행 계획을 수립
MySQL 8.0 부터는 인덱스되지 않은 칼럼에 대해서도 데이터 분포도를 수집해서 저장(히스토그램)

#### 테이블 및 인덱스 통계 정보
5.6 버전 부터 InnoDB 스토리지 엔진 사용하는 테이블에 대한 통계정보를 별도의 테이블로 영구적으로 관리 (이전 까지는 메모리로만 관리)

#### 히스토그램(Histogram)
옵티마이저의 실행 계획 최적화를 위해 컬럼의 데이터 분포도를 참조할 수 있도록 MySQL 8.0 부터 지원
버킷 단위로 구분하여 레코드 건수나 컬럼값 범위를 관리

	- Singleton(싱글톤) 히스토그램
	컬럼값 개별로 레코드 건수를 관리(도수 분포)
	컬럼이 가질 수 있는 값에 대한 누적된 레코드 건수 비율
	코드 값 등 유니크한 값의 개수가 상대적으로 적은 경우에 사용

	- Equi-Height(높이 균형) 히스토그램
	컬럼값의 범위를 균등한 개수로 구분하여 관리
	레코드 건수 비율이 누적으로 표시

히스토그램이 없는 경우 옵티마이저는 데이터가 균등하게 분포되어 있다고 예측
하지만 실제 데이터는 항상 균등한 분포도를 가지지 않음
컬럼의 히스토그램 정보로 어느 테이블을 먼저 읽어야 조인의 횟수를 줄일 수 있는지에 대해 옵티마이저가 더 정확한 판단 가능

#### 코스트 모델(Cost Model)

MySQL 서버가 쿼리를 처리할 때 필요한 작업
	- 디스크로 부터 데이터 페이지 읽기
	- 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
	- 인덱스 키 비교
	- 레코드 평가 
	- 메모리 임시 테이블 작업
	- 디스크 임시 테이블 작업

MySQL 서버에서는 사용자 쿼리에 대해 이런 작업이 얼마나 필요한지 예측하고 비용을 계산해 최적의 실행 계획을 찾음

이 때 비용 계산에 필요한 단위 작업의 비용을 코스트 모델이라고 함
MySQL 5.7부터 단위작업 비용 상수를 DBMS 관리자가 조정할 수 있도록 개선
	- server_cost : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
	- engine_cost : 레코드를 가진 데이터 페이지를 가져오는데 필요한 비용 관리

### 실행 계획 확인
EXPLAIN EXTENDED, EXPLAIN PARTITIONS 으로 구분된 명령은 MySQL 8.0 부터 통합
	- EXPLAIN : 테이블 포맷 표시
	- EXPLAIN FORMAT=TREE : 트리 포맷 표시
	- EXPLAIN FORMAT=JSON: JSON 포맷 표시
	- EXPLAIN ANALYZE : 쿼리의 실행 계획과 단계별 소요시간 정보 확인
		- actual time : 실제 소요된 시간
		- rows : 처리한 레코드 건수
		- loops : 반복 횟수

EXPLAIN ANALYZE 명령은 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요 시간을 보여줌


### 실행 계획 분석
#### 1. id 컬럼
하나의 SELECT 문장은 아래와 같이 1개 이상의 SUB SELECT 문장을 포함 가능
```
SELECT...
FROM (SELECT .. FROM tb1) tb1, tb2
WHERE tb1.id=tb2.id;
```

이런 문장을 SELECT 키워드 단위로 나눈 것을 단위 SELECT 쿼리라고 함 
실행 계획의 id 컬럼은 단위 SELECT 쿼리의 식별자 값
조인된 경우에는 테이블 개수만큼 실행 계획 레코드가 출력되지만 같은 id 값이 부여됨

#### 2. select_type 컬럼
각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시

1. SIMPLE
UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리에서 가장 바깥 쪽의 단위 쿼리
한 SQL 문에서 SIMPLE인 단위 쿼리는 하나만 존재

2. PRIMARY
UNION이나 서브쿼리를 사용하는 SELECT 쿼리에서 가장 바깥 쪽의 단위 쿼리
SIMPLE과 마찬가지로 한 SQL 문에 하나만 존재

3. UNION
UNION으로 결합하는 단위 SELECT 쿼리 중 두 번째 이후 단위 SELECT 쿼리
UNION의 첫 번째 단위 SELECT 쿼리는 DERIVED (임시 테이블)

4. DEPENDENT UNION
UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미 (내부 쿼리가 외부의 값을 참조해서 처리될 때)

5. UNION RESULT
UNION 결과를 담아두는 테이블
MySQL 8.0 부터는 UNION ALL의 경우에는 임시 테이블을 사용하지 않음
실제 쿼리에서 단위 쿼리가 아니기 때문에 id 값 부여되지 않음

6. SUBQUERY
FROM 절 이외에서 사용되는 서브쿼리

7. DEPENDENT SUBQUERY
서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 컬럼을 사용하는 경우
외부 쿼리가 먼저 수행되어야 하므로 일반 서브쿼리보다 처리 속도가 느린 경우가 많음

8. DERIVED
MySQL 5.5 버전까지는 FROM 절의 서브쿼리가 항상 DERIVED 였지만, 이후 버전은 옵티마이저 옵션에 따라 FROM 절의 서브쿼리가 외부 쿼리와 통합되는 최적화 수행되기도 함
단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블 생성을 의미

9. DEPENDENT DERIVED
MySQL 8.0 버전부터 사용 가능한 외부 컬럼을 사용한 FROM 절의 서브쿼리
(LATERAL JOIN)

10. UNCACHEABLE SUBQUERY
조건이 똑같은 서브쿼리가 실행될 때 다시 실행하지 않도록 서브쿼리 결과를 내부적인 캐시 공간에 담아둠

캐시를 사용하지 못하는 경우
	- 사용자 변수가 서브쿼리에 사용
	- NOT-DETERMINISTIC 속성의 스토어드 루틴이 서브쿼리 내 사용된 경우
	- UUID(), RAND() 등 결과값이 호출할 때마다 달라지는 함수가 서브쿼리에 사용

11. UNCACHEABLE UNION

12. MATERIALIZED
FROM 절이나 IN(subquery) 형태의 쿼리에 사용된 서브쿼리의 최적화를 위해 사용
MySQL 5.6 버전까지는 레코드마다 IN 쿼리의 서브쿼리가 실행
MySQL 5.7 버전부터는 서브쿼리의 내용을 임시 테이블로 구체화한 뒤, 임시 테이블과 조회 테이블을 조인하는 형태로 최적화


#### 3. table 컬럼
MySQL 서버의 실행계획은 테이블 기준으로 표시
테이블에 별칭이 부여된 경우 별칭이 표시
별도 테이블을 사용하지 않는 경우 NULL
임시 테이블을 사용하는 경우 <derived N> <union M,N>
여기서 N은 단위 SELECT 쿼리의 id 값을 지칭

#### 4. partitions 컬럼
MySQL 5.7 버전까지는 EXPLAIN PARTITION 명령으로 확인
MySQL 8.0 버전부터는 EXPLAIN 명령으로 파티션 관련 실행 계획까지 확인

#### 5. type 컬럼
MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지 나타냄

- system
레코드가 1건만 존재하거나 한 건도 존재하지 않는 테이블 참조
InnoDB 스토리지 엔진에서는 나타나지 않음(MyISAM, MEMORY)	

- const
프라이머리 키나 유니크 키 컬럼을 이용하는 WHERE 조건절
반드시 1건을 반환하는 쿼리의 처리 방식	
옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해서 통째로 상수화

- eq_ref
여러 테이블이 조인되는 쿼리의 실행 계획
조인에서 처음 읽은 테이블의 컬럼값을 다음 읽을 테이블의 기본키나 유니크키 컬럼의 검색 조건에 사용
유니크 인덱스가 NOT NULL인 경우
다중 컬럼의 기본키 또는 유니크키면 모든 컬럼이 비교조건에 사용되는 경우

- ref
조인의 순서와 상관없이 인덱스의 종류와 관계없이 동등 조건으로 검색
1건의 레코드만 반환된다는 보장이 없어도 됨

-> const, eq_ref, ref 세 가지 접근 방식 모두 인덱스의 분포도가 나쁘지 않는다면 성능상의 문제를 일으키지 않기 때문에 쿼리를 튜닝하는 경우 크게 신경쓰지 않아도 괜찮다고 함

- fulltext
MySQL 서버의 전문 검색 인덱스를 사용해 레코드를 읽는 접근 방식
MATCH (…) AGAINST (…) 구문을 이용하는 경우에 해당하고 전문 검색용 인덱스가 있어야 함
일반 인덱스를 이용하는 방식보다 fulltext 접근 방식이 먼저 처리하지만, 느린 경우가 많으므로 조건별 성능 확인이 필요

- ref_or_null
ref 접근 방식과 같은데 NULL 비교가 추가된 형태

- unique_subquery
WHERE 조건절에서 사용되는 IN (subquery) 형태의 쿼리를 위한 접근 방식
서브쿼리에서 중복되지 않는 유니크한 값만 반환될 때 이 방식을 사용

- index_subquery
서브쿼리 결과에서 중복된 값이 있지만 인덱스를 이용해 서브쿼리 결과의 중복 값을 제거할 수 있을 때 사용

- range
인덱스를 하나의 값이 아니라 범위로 검색
필요한 레코드 양에 따라 차이는 있지만 상당히 빠른 접근 방식

- index_merge
2개 이상의 인덱스로 각각의 검색 결과를 만들고, 그 결과를 병합해서 처리하는 방식
여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방식보다 효율성이 떨어짐
전문 검색 인덱스를 사용하는 쿼리에는 index_merge가 적용되지 않음
처리 결과가 항상 2개 이상의 집합이 되기 떄문에 추가적인 작업이 필요(교집합, 합집합, 중복제거 등)

- index
인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미
풀 테이블 스캔 방식과 비교하는 레코드 건수는 같지만 인덱스 크기가 데이터 파일 전체 크기보다 작으므로 더 빠르게 처리됨
range나 const, ref 같은 접근 방법으로 인덱스를 사용하지 못할 때, 인덱스에 포함된 컬럼만으로 처리할 수 있거나 인덱스로 정렬/그루핑 작업이 가능한 경우 사용

- ALL
풀 테이블 스캔을 의미
테이블을 처음부터 끝까지 읽어서 불필요한 레코드를 제거한 뒤 반환
가장 마지막에 선택되는 비효율적인 방식

**Read Ahead**
풀 테이블 스캔이나 인덱스 풀 스캔 같은 대량의 디스크 I/O를 유발하는 작업을 위해 한 번에 여러 페이지를 읽어서 처리하는 기능
데이터 웨어하우스나 배치 프로그램처럼 대용량의 레코드를 처리하는 쿼리에서 잘못 튜닝된 쿼리보다 더 나은 방식

-> index와 ALL 접근 방식은 작업 범위를 제한하지 않아 빠른 응답을 할 수 없음
테이블이 매우 작은 경우가 아니라면 데이터를 미리 저장해서 쿼리의 성능 확인이 필요

#### 6. possible_keys 컬럼
옵티마이저에서 실행계획을 만들기 위한 인덱스의 사용후보

#### 7. key 컬럼
실행계획에서 최종 선택된 인덱스
의도했던 인덱스가 표시되는지 확인이 필요 

#### 8. key_len 컬럼
중요한 정보 중 하나로, 쿼리를 처리하기 위해 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값
CHAR(4) 인덱스의 경우 16이 표시 (4*4 byte)
CHAR(4) 인덱스와 INTEGER 타입의 컬럼을 조건에 동시에 사용(AND)한 경우 20이 표시
CHAR(4)(16 byte) + INTEGER(4byte) = 20

#### 9. ref 컬럼
접근 방식이 ref인 경우 참조 조건으로 어떤 값이 제공되었는지 표시(cost 또는 테이블명+컬럼명)
ref 컬럼 값이 func가 표시되는 경우 참조되는 값이 콜레이션 변환이나 값 자체 연산을 거쳐 참조된 것으로 확인이 필요 (조인시 문자집합 불일치 or 연산, or 타입 불일치)

#### 10. rows 컬럼
옵티마이저가 실행 계획의 효율성 판단을 위해 통계 정보를 참조해 산출해낸 예상 값
쿼리를 처리하기 위해 읽고 체크해야하는 레코드 수를 예측한 값

#### 11. filtered 컬럼
rows 컬럼의 값은 인덱스를 사용하는 조건에만 일치하는 레코드 건수를 예측
하지만 쿼리에서 모든 조건이 인덱스를 사용할 수 있는 것은 아니므로, 인덱스를 사용하지 못하는 조건에 일치하는 레코드 건수를 파악이 필요


#### 12. Extra 컬럼
주로 내부적인 처리 알고리즘에 대한 깊이 있는 내용으로 성능에 관련된 중요 내용도 포함되는 경우가 있음




