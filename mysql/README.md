# MySQL
#TIL/MySQL

## MySQL 엔진 아키텍처
MySQL 서버 = MySQL 엔진 + 스토리지 엔진

### MySQL 엔진
클라이언트 접속 및 쿼리 요청 처리하는 커넥션 핸들러
SQL 파서 및 전처리기
쿼리의 최적화된 실행을 위한 옵티마이저

### 스토리지 엔진
실제 데이터를 디스크 스토리지에 저장하거나 데이터를 읽어오는 부분 전담
MySQL 엔진은 하나를 사용하고 스토리지 엔진은 여러 개를 동시에 사용 가능
MyISAM 스토리지 엔진 (키 캐시)
InnoDB 스토리지 엔진 (InnoDB 버퍼 풀)

### 핸들러(Handler) API
핸들러 요청에 사용되는 API

핸들러(Handler) 요청 : MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야할 때 스토리지 엔진에 보내는 요청

``` 
# 핸들러 API 조회
mysql> SHOW GLABAL STATUS LIKE ‘Handler%’; 
```


## MySQL 스레딩 구조

![](README/C414F661-7644-46D5-B044-0AB023FA29AB.png)

### 포그라운드(Foreground) 스레드
최소 MySQL 서버에 접속된 클라이언트 수만큼 존재
각 클라이언트가 요청하는 쿼리 문장 처리
커넥션 종료시 스레드 캐시(Thread cahce)로 돌아가는데 일정 개수 이상 스레드가 있으면 종료(thread_cache_size)
MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리

### 백그라운드(Background) 스레드
인서트 버퍼를 병합
로그를 디스크로 기록
InnoDB 버퍼 풀 데이터를 디스크에 기록
데이터를 버퍼로 읽어옴
잠금이나 데드락 모니터링


## 메모리 구조
### 글로벌 메모리 영역	
	- 테이블 캐시
	- InnoDB 버퍼 풀
	- InnoDB 어댑티브 해시 인덱스
	- InnoDB 리두 로그 버퍼
클라이언트 스레드 수와 무관
모든 스레드에 의해 공유


### 로컬 메모리 영역(세션 메모리 영역)
	- 정렬 버퍼(Sort buffer)
	- 조인 버퍼
	- 바이너리 로그 캐시
	- 네트워크 버퍼
MySQL 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용
각 클라이언트 스레드별 독립적 할당, 공유되지 않음
각 쿼리의 용도별로 필요할 때만 공간이 할당될 수도 있음

### 플러그인 스토리지 엔진 모델
MySQL의 독특한 구조 중 대표적인 것
전문 검색 엔진을 위한 검색어 파서, 사용자 인증을 위한 Native Authentication 등이 플러그인으로 구현되어 제공
사용자가 직접 스토리지 엔진을 개발할 수 있음

### 컴포넌트
MySQL 8.0 이후 제공되는 아키텍처
플러그인의 단점을 개선
	- MySQL 서버만 인터페이스 가능, 플러그인끼리 통신 불가
	- MySQL 서버의 변수나 함수를 직접 호출 (캡슐화 안됨)
	- 상호 의존 관계 설정할 수 없어 초기화가 어려움


## 쿼리 실행 구조

![](README/DA27BE1F-81D4-4047-91B0-BFB82BEB849F.png)

### 쿼리 파서
사용자 요청으로 들어온 문장을 토큰으로 분리해 트리 구조로 만드는 작업
토큰 : MySQL이 인식할 수 있는 최소 단위의 어휘나 기호

### 전처리기
파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장의 문제점 여부 확인
테이블, 컬럼, 함수명 등을 매핑하여 객체 존재여부 및 접근권한 확인

### 옵티마이저
쿼리 문장을 어떻게 적은 비용으로 빠른 처리할지 결정
옵티마이저가 더 나은 선택을 하도록 유도하는 것이 필요

### 실행 엔진
만들어진 계획대로 각 핸들러에 요청한 뒤, 요청 결과를 다른 핸들러 요청의 입력으로 연결

### 핸들러(스토리지 엔진)
데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할(=스토리지 엔진)

## 쿼리 캐시(Query Cache)
SQL 실행 결과를 메모리에 캐시하고 동일한 SQL 쿼리가 실행되면 즉시 결과를 반환
데이터가 변경될 경우 캐시 결과 중 관련 데이터를 모두 삭제하는데, 이 때 동시 처리 성능 저하가 유발되었고, 성능 개선되는 과정에서 많은 버그의 원인이 되면서 MySQL 8.0에서는 제거됨

## 스레드 풀(Thread Pool)
엔터프라이즈 에디션에서는 제공하지만 커뮤니티 에디션은 지원하지 않음

### Percona Server에서 제공하는 스레드 풀
플러그인 형태로 작동
사용자 요청을 처리하는 스레드 개수를 줄여서 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있도록 자원 소모를 줄임


## InnoDB 스토리지 엔진 아키텍처
스토리지 엔진 중 유일하게 레코드 기반 잠금을 제공 -> 높은 동시성 처
리
안정적이며 성능이 뛰어남

## 인덱스
### 디스크 읽기 방식
#### HDD와 SSD


## 옵티마이저
### 쿼리 실행 절차
1. 요청된 SQL 문장을 쪼개 MySQL 서버가 이해할 수 있는 수준으로 분리 
(SQL 파서: SQL Parsing 수행 -> SQL 파스 트리 생성)
2. SQL 파싱정보를 확인하며 어떤 테이블부터 어떤 인덱스로 테이블을 읽을지 선택
(옵티마이저: 최적화 및 실행 계획 수립 -> 실행 계획 수립)
3. 2단계에서 결정된 읽기 순서 또는 선택된 인덱스로 스토리지 엔진에서 데이터를 가져옴

### 옵티마이저 종류

1. 비용 기반 최적화(Cost-based optimizer, CBO)
쿼리를 처리하기 위한 여러 가능한 방법 생성 
-> 각 단위 작업의 비용 정보와 테이블 예측 통계로 실행 게획별 비용을 산출
-> 비용이 최소로 소요되는 처리 방식으로 쿼리 실행

2. 규칙 기반 최적화(Rule-based optimizer, RBO)
옵티마이저에 내장된 우선 순위에 따라 실행 게획을 수립
테이블의 레코드 건수나 컬럼값의 분포도 조사하지 않고 수립되어, 같은 쿼리는 거의 항상 같은 실행 방법을 만듬

현재 대부분의 RDBS가 비용 기반의 옵티마이저를 채택 (MySQL 포함)

#### 기본 데이터 처리
##### 풀 테이블 스캔

## 실행 계획
### 통계정보
MySQL 5.7 까지는 테이블과 인덱스에 대한 개괄적인 정보로 실행 계획을 수립
MySQL 8.0 부터는 인덱스되지 않은 칼럼에 대해서도 데이터 분포도를 수집해서 저장(히스토그램)

#### 테이블 및 인덱스 통계 정보
5.6 버전 부터 InnoDB 스토리지 엔진 사용하는 테이블에 대한 통계정보를 별도의 테이블로 영구적으로 관리 (이전 까지는 메모리로만 관리)

#### 히스토그램(Histogram)
옵티마이저의 실행 계획 최적화를 위해 컬럼의 데이터 분포도를 참조할 수 있도록 MySQL 8.0 부터 지원
버킷 단위로 구분하여 레코드 건수나 컬럼값 범위를 관리

- Singleton(싱글톤) 히스토그램
컬럼값 개별로 레코드 건수를 관리(도수 분포)
컬럼이 가질 수 있는 값에 대한 누적된 레코드 건수 비율
코드 값 등 유니크한 값의 개수가 상대적으로 적은 경우에 사용

- Equi-Height(높이 균형) 히스토그램
컬럼값의 범위를 균등한 개수로 구분하여 관리
레코드 건수 비율이 누적으로 표시

히스토그램이 없는 경우 옵티마이저는 데이터가 균등하게 분포되어 있다고 예측
하지만 실제 데이터는 항상 균등한 분포도를 가지지 않음
컬럼의 히스토그램 정보로 어느 테이블을 먼저 읽어야 조인의 횟수를 줄일 수 있는지에 대해 옵티마이저가 더 정확한 판단 가능

#### 코스트 모델(Cost Model)

MySQL 서버가 쿼리를 처리할 때 필요한 작업
- 디스크로 부터 데이터 페이지 읽기
- 메모리(InnoDB 버퍼 풀)로부터 데이터 페이지 읽기
- 인덱스 키 비교
- 레코드 평가 
- 메모리 임시 테이블 작업
- 디스크 임시 테이블 작업

MySQL 서버에서는 사용자 쿼리에 대해 이런 작업이 얼마나 필요한지 예측하고 비용을 계산해 최적의 실행 계획을 찾음

이 때 비용 계산에 필요한 단위 작업의 비용을 코스트 모델이라고 함
MySQL 5.7부터 단위작업 비용 상수를 DBMS 관리자가 조정할 수 있도록 개선
- server_cost : 인덱스를 찾고 레코드를 비교하고 임시 테이블 처리에 대한 비용 관리
- engine_cost : 레코드를 가진 데이터 페이지를 가져오는데 필요한 비용 관리

### 실행 계획 확인
EXPLAIN EXTENDED, EXPLAIN PARTITIONS 으로 구분된 명령은 MySQL 8.0 부터 통합
- EXPLAIN : 테이블 포맷 표시
- EXPLAIN FORMAT=TREE : 트리 포맷 표시
- EXPLAIN FORMAT=JSON: JSON 포맷 표시
- EXPLAIN ANALYZE : 쿼리의 실행 계획과 단계별 소요시간 정보 확인
	- actual time : 실제 소요된 시간
	- rows : 처리한 레코드 건수
	- loops : 반복 횟수

EXPLAIN ANALYZE 명령은 실행 계획만 추출하는 것이 아니라 실제 쿼리를 실행하고 사용된 실행 계획과 소요 시간을 보여줌


### 실행 계획 분석
#### 1. id 컬럼
하나의 SELECT 문장은 아래와 같이 1개 이상의 SUB SELECT 문장을 포함 가능
```
SELECT...
FROM (SELECT .. FROM tb1) tb1, tb2
WHERE tb1.id=tb2.id;
```

이런 문장을 SELECT 키워드 단위로 나눈 것을 단위 SELECT 쿼리라고 함 
실행 계획의 id 컬럼은 단위 SELECT 쿼리의 식별자 값
조인된 경우에는 테이블 개수만큼 실행 계획 레코드가 출력되지만 같은 id 값이 부여됨

#### 2. select_type 컬럼
각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시

1. SIMPLE
UNION이나 서브쿼리를 사용하지 않는 단순한 SELECT 쿼리에서 가장 바깥 쪽의 단위 쿼리
한 SQL 문에서 SIMPLE인 단위 쿼리는 하나만 존재

2. PRIMARY
UNION이나 서브쿼리를 사용하는 SELECT 쿼리에서 가장 바깥 쪽의 단위 쿼리
SIMPLE과 마찬가지로 한 SQL 문에 하나만 존재

3. UNION
UNION으로 결합하는 단위 SELECT 쿼리 중 두 번째 이후 단위 SELECT 쿼리
UNION의 첫 번째 단위 SELECT 쿼리는 DERIVED (임시 테이블)

4. DEPENDENT UNION
UNION이나 UNION ALL로 결합된 단위 쿼리가 외부 쿼리에 의해 영향을 받는 것을 의미 (내부 쿼리가 외부의 값을 참조해서 처리될 때)

5. UNION RESULT
UNION 결과를 담아두는 테이블
MySQL 8.0 부터는 UNION ALL의 경우에는 임시 테이블을 사용하지 않음
실제 쿼리에서 단위 쿼리가 아니기 때문에 id 값 부여되지 않음

6. SUBQUERY
FROM 절 이외에서 사용되는 서브쿼리

7. DEPENDENT SUBQUERY
서브쿼리가 바깥쪽 SELECT 쿼리에서 정의된 컬럼을 사용하는 경우
외부 쿼리가 먼저 수행되어야 하므로 일반 서브쿼리보다 처리 속도가 느린 경우가 많음

8. DERIVED
MySQL 5.5 버전까지는 FROM 절의 서브쿼리가 항상 DERIVED 였지만, 이후 버전은 옵티마이저 옵션에 따라 FROM 절의 서브쿼리가 외부 쿼리와 통합되는 최적화 수행되기도 함
단위 SELECT 쿼리의 실행 결과로 메모리나 디스크에 임시 테이블 생성을 의미

9. DEPENDENT DERIVED


10. UNCACHEABLE SUBQUERY


11. UNCACHEAblE UNION


12. MATERIALIZED















