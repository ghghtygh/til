# 마이크로서비스 패턴
### 확장 큐브
X축 확장 : 다중 인스턴스에 요청 분산
Z축 확장 : 조건에 따라 요청 분산
Y축 확장 : 기능에 따른 애플리케이션 분해

SOA
서비스간 통신에 SOAP, WS 표준 등을 사용
서비스 통합 및 메시지 처리 로직에 ESB라는 스마트 파이프 활용
일정 개수 이하의 크고 복잡한 모놀리식 애플리케이션을 통합하는 용도

MSA
서비스간 통신에 메시지 브로커나 REST 또는 gRPC 같은 가벼운 프로토콜 위주 덤 파이프를 사용
규모가 작은 수십~수백개의 서비스로 구성

MSA 장점
크고 복잡한 애플리케이션을 지속적으로 전달 및 배포
서비스 규모가 작기 때문에 관리 용이
서비스 독립적으로 배포 및 확장 가능
결함 격리에 용이
새로운 기술 실험 및 도입이 용이

MSA 단점
모놀리식 아키텍처를 알맞게 분해하기가 어려움
복잡한 분산 시스템으로 개발, 테스트, 배포가 어려움
여러 서비스에 걸친 기능의 배포시 알맞은 조정이 필요
MSA 도입 시점 결정의 어려움

MSA 패턴 구분
- 인프라 패턴 : 개발 영역 밖 인프라 문제 해결
- 애플리케이션 인프라 : 개발에 영향을 미치는 인프라 문제 해결
- 애플리케이션 패턴 : 개발자가 맞닥뜨리는 문제 해결

레이어드 아키텍처
계층마다 명확히 정의된 역할을 분담
계층 간 디펜던시는 아키텍처로 제한
표현(프레젠테이션) 계층 : 사용자 인터페이스 또는 외부 API 구현
비즈니스 로직 계층
영속화(퍼시스턴스) 계층 : DB 상호 작용 로직이 구현된 계층

헥사고날 아키텍처
논리 뷰를 비즈니스 로직 중심으로 구성
인바운드 어댑터 : 표현 계층 대신 비즈니스 로직을 호출하여 외부 요청을 처리
아웃바인드 어댑터 : 영속화 계층 대신 비즈니스 로직에서 들어온 요청을 외부 애플리케이션/서비스를 호출해서 처리
포트 : 비즈니스 로직에 하나 이상 존재하며, 자신이 외부세계와 상호작용하는 방법이 정의(자바 인터페이스)
인바운드 포트 : 비즈니스 로직이 표출된 API (public 메서드 정의된 서비스 인터페이스)
아웃바운드 포트 : 비즈니스 로직이 외부 시스템을 호출하는 방법(리포지터리 인터페이스)

비즈니스 로직의 표현/데이터 접근 로직에 의존하지 않음(어댑터와 분리)
비즈니스 로직의 테스트가 용이
다양한 외부 시스템을 호출하거나 여러 형태의 UI로 구현된 현대 애플리케이션 아키텍처를 좀 더 정확하게 반영 가능

## 분해 전략

1단계 시스템 작업 식별
애플리케이션 요건을 핵심 요청으로 추출

2단계 서비스 식별
어떻게 서비스를 분해할지 결정

3단계 서비스 API 및 협동 정의

## 프로세스 간 통신
### 클라이언트/서비스 상호작용 스타일
#### 일대일/일대다 여부
일대일 : 각 클라이언트 요청을 한 서비스가 처리
일대다 : 각 클라이언트 요청을 여러 서비스가 협동해서 처리

#### 동기/비동기 여부
동기 : 클라이언트 제시간 응답을 기대하고 대기 중 블로킹
비동기 : 클라이언트가 블로킹하지 않음, 응답 즉시 전송 X

#### 일대일 상호작용 종류
요청/응답 : 클라이언트가 서비스에 요청 후 응답을 기다림 -> 서비스가 강하게 결합
비동기 요청/응답 : 클라이언트가 요청한 서비스가 비동기적으로 응답
단방향 알림 : 클라이언트가 서비스에 일방적으로 요청, 서비스 응답 X

#### 일대다 상호작용 종류
발행/구독 : 클라이언트에서 알림 메시지 발행 후, 관심있는 서비스들이 메시지 소비
발행/비동기 응답 : 클라이언트가 요청 메시지 발행 후, 주어진 시간 동안 관련 서비스의 응답을 기다림

### 마이크로 API 정의
클라이언트가 호출 가능한 작업과 서비스가 발행되는 이벤트로 구성
작업 : 이름, 매개변수, 반환타입
이벤트 : 타입, 필드를 가지며 메시지 채널에 발행

### API 발전시키기
MSA에서 무중단 상태로 서비스 API를 변경하기 위해 전략이 필요

#### 시맨틱 버저닝 명세(Semvers, Semantic Versioning specification)
버전 번호를 사용하고 증가시키는 규칙 명시
버전 번호를 MAJOR, MINOR, PATH 파트로 구성
- MAJOR : 하휘 호환되지 않는 변경 API 적용
- MANOR : 하휘 호환되는 변경 API 적용
- PATCH : 하휘 호환되는 오류 수정

#### 하휘 호한되는 소규모 변경
- 옵션 속성을 요청에 추가
- 속성을 응답에 추가
- 새 작업 추가
클라이언트/서비스가 견고성 원칙을 뒷받침하는 요청/응답 포맷을 사용해야 함

#### 중대한 대규모 변경
기존 버전과 호환이 안되는 중요한 변경이 있는 경우, 일괄적으로 강제 업데이트하는 것이 불가하므로 일정 기간동안 서비스는 신구 버전 API 모두 지원해야함
REST API라면 URL에 메이저 버전 번호 삽입
HTTP content negotiation으로 버전 번호를 끼워넣는 방법도 존재
여러 버전의 API를 지원하기 위해서는 API 구현된 서비스 어댑터에 신구버전의 중계 로직이 있어야 함

### 메시지 포맷
데이터 포맷은 IPC 효율, API 사용성, 발전성에 많은 영향을 끼침
gRPC는 메시지 포맷이 정해져 있음
자바 직렬화는 자바에 국한되므로 사용되지 않음

#### 텍스트 메시지 포맷
JSON, XML 등 텍스트 기반 포맷은 사람이 읽을 수 있음
메시지 스키마가 바뀌어도 하위 호환성이 쉽게 보장
JSON에서도 XML 스키마 같은 JSON 스키마 표준이 제정 (메시지 프로퍼티명, 타입, 필수여부)
메시지가 다소 길고, 메시지 이외 속성명이 추가되거나 텍스트를 파싱하는 오버헤드 발생

#### 이진 메시지 포맷
메시지 구조 정의에 필요한 타입 IDL을 제공하며 컴파일러에서 메시지를 직렬화/역직렬화하는 코드를 생성
- 스리프트(Thrift)
데이터 직렬화 라이브러리 + RPC 프레임워크 (원격 호출)
단일 바이너리 인코딩을 표준으로 하는 프로토콜 버퍼와 아브로와 다르게 다양한 직렬화 포맷을 포함
- 프로토콜 버퍼
직렬화/역직렬화 속도가 빠르고, 직렬화 파일 크기를 월등히 줄임 -> 대용량 데이터 처리 성능 좋음
스키마를 변경할 때 필드이름은 바꿀 수 있지만(필드이름이 바이너리에 없어서) 태그 번호는 바꿀 수 없음
- 아브로
아브로의 컨슈머는 스키마를 알고 있어야 해석이 가능함
데이터의 쓸때와 읽을 때 정확히 같은 버전이 필요함
필드에 대한 지시자가 없어서 스키마에 보이는 순서로 차례대로 인코딩

### 동기 RPI 패턴 응용 통신
RPI : 클라이언트가 서비스에 요청을 보냈을 때 서비스가 처리 후 응답을 회신하는 IPC
1. 클라이언트의 비즈니스 로직이 프록시 인스턴스 호출
2. 프록시 인터페이스는 RPI 프록시 어댑터 클래스로 구현
3. RPI 프록시가 서비스에 전달한 요청은 RPI 서버 어댑터 클래스가 접수
4. 비즈니스 로직을 마친 서비스는 RPI 프록시로 응답을 반환
5. 최종 결과 클라이언트 비즈니스 로직에 반환

프록시 인터페이스는 하부(underlying) 통신 프로토콜을 캡슐화

### 동기 RPI 패턴 : REST
HTTP로 소통하는 IPC
HTTP 동사를 사용해서 URL로 참조되는 리소스를 조작
REST API
스웨거라는 오픈소스 프로젝트를 발전시켜 Open API Specification를 REST IDL로 보급
스웨거
REST API를 문서화하는 도구
인터페이스 정의를 기반으로 클라이언트 스텁이나 서버 스켈레톤을 생성하는 툴 포함

요청 한번으로 많은 리소스를 가져오기 어려움
특정 주문과 소비자를 같이 가져오고 싶을 때 두번의 요청을 하게되는데
왕복 횟수가 많아지면서 지연이 늘어남
리소스 획득시 연관된 리소스를 조회하도록 할 수 있으나 효율이 떨어지며 GraphQL이나 넷플릭스 팔코 등 대체 API 기술 사용

GraphQL
클라이언트에서 자신에게 필요한 데이터만을 쿼리할 수 있도록 해줌
필요한 데이터에 대한 쿼리를 선언해 넘기면 쿼리를 해석해서 해당 데이터를 알맞은 형태로 반환 
네트워크 IO를 줄일 수 있지만 서버의 부담이 가중
클라이언트가 결정한 데이터가 잘못됬는지 알기 어려워 요청을 필터링하기 어려움
고정된 요청의 응답만 필요할 때는 쿼리로 인해 request 크기가 커짐
캐싱이 복잡함

Falcor
효율적으로 데이터를 가져오기 위한 자바스크립트 라이브러리
GraphQL과 용도가 비슷함
JSON Graph의 레퍼런스 타입을 이용할 수 있어 중복된 데이터를 조회하는 것과 그에 따른 오버페치를 제거
falcor model을 통해서 HttpDataSource를 호출하면 GET 방식으로 데이터를 호출하기 때문에 중복호출시 브라우저 캐싱을 이용할 수 있음

REST 장점
단순하고 익숙함
포스트맨이나 curl 등의 도구로 API를 간편하게 테스트 가능
중간 브로커가 필요하지 않음

REST 단점
요청/응답 통신만 지원
교환 일어나는 동안 양쪽이 모두 실행 중이어야 함 
서비스의 인스턴스를 클라이언트가 알고 있어야 함
요청 한번으로 여러 리소스를 가져오기 어려움
다중 업데이트 작업을 HTTP 동사에 매핑하기가 어려움

#### 동기 RPI 패턴 : gRPC
다양한 언어로 클라이언트/서버를 작성할 수 있는 프로토콜
바이너리 기반 프로토콜로 프로토콜 버퍼 기반의 IDL로 정의
하나 이상의 서비스와 요청/응답 메시지 데피니션으로 구성
서비스 데피니션은 자바 인터페이스와 비슷하게 정적 타입 메서드를 모아놓은것

프로토콜 버퍼
각 필드마다 번호가 매겨지고 타입 코드가 할당 
필요한 필드만 추출할 수 있기 때문에 하위 호환성 유지하며 API 발전 가능

gRPC는 REST를 대체할 방안이지만 REST처럼 동기 통신하는 매커니즘으로 부분 실패 문제가 존재

#### 회로 차단기 패턴
연속 실패 횟수가 임계치를 초과하면 일정 시간동안 호출을 거부하는 RPI 프록시

부분실패시 정해진 기본값이나 캐시된 응답 등의 대체 값 반환 방법도 가능

### 서비스 디스커버리
REST API 서비스를 호출하는 코드에서 서비스 인스턴스의 네트워크 위치(IP 주소 + 포트)를 알아야 하는데 이를 담당
어플리케이션 서비스 인스턴스의 네트워크 위치를 데이터베이스화한 서비스 레지스트리를 가지고 있어서 요청을 라우팅 가능

자가등록 패턴 : 서비스 인스턴스가 자신의 네트워크 위치를 서비스 레지스트리 등록 API를 호출해서 등록
클라이언트 디스커버리 패턴 : 서비스를 호출할 때 서비스 레지스트리의 서비스 인스턴스 목록을 요청해서 넘겨받음

### 비동기 메시징 패턴 응용 통신

#### 메시지 
헤더와 본문으로 구성
헤더는 송신된 데이터에 대한 메타데이터 키/값으로 구성
문서 : 제네릭
커맨드 : RPC 요청과 동등한 메시지
이벤트 : 송신자에게 사건이 발생했음을 알리는 메시지




## 트랜잭션 관리

## 비즈니스 로직 설계

## 비즈니스 로직 개발: 이벤트 소싱

## 마이크로서비스 쿼리 구현

## 외부 API 패턴

