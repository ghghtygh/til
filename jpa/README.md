# JPA
#TIL/JPA

## JPA
### JPA(Java Persistence API)
자바 진영의 ORM 기술 표준
애플리케이션과 JDBC 사이에서 동작

### ORM (Object-Relational Mapping)
객체와 관계형 데이터베이스를 매핑하는 것
자바 컬렉션에 저장하듯이 ORM 프레임워크에 저장하면 INSERT SQL을 생성하여 DB에 객체를 저장해줌
데이터 중심인 RDBMS를 사용해도 객체지향 어플리케이션 개발에 집중할 수 있음

### JPA 장점
CRUD SQL과 같은 반복적인 코드를 직접 작성하지 않아도 되며, DDL문 생성 등 JPA가 대신 처리해주는 기능이 많아 생산성이 좋음
SQL문을 직접 작성하게 되면 엔티티 변경에 따라 변경되어야 하는 코드 수가 많지만, JPA를 사용하면 유지보수해야하는 코드 수가 줄어듬
상속, 연관관계, 객체 그래프 탐색, 비교 등의 패러다임 불일치 문제 해결
애플리케이션과 데이터베이스 사이에 위치하여 성능 최적화 기회 제공
데이터 접근 추상화에 따라 특정 데이터베이스 기술에 종속되지 않는 벤더 독립성

### JPQL(Java Persistence Query Language)
JPA에서 제공하는, SQL을 추상화한 객체지향 쿼리 언어
SQL의 문법을 사용하지만 엔티티 객체(클래스, 필드)를 대상으로 쿼리

## 엔티티 매니저 팩토리(EntityManagerFactory)
JPA에서 제공하는 기능의 분류
- 엔티티와 테이블을 매핑하는 설계하는 부분
- 매핑한 엔티티를 실제로 사용하는 부분 -> 엔티티 매니저(Entity Manager)

엔티티 매너지 팩토리를 통해 엔티티 매니저를 생성 (저비용)

엔티티 매니저는 데이터베이스 연결이 필요한 시점(보통 트랜잭션 시작시점)에 커넥션을 획득

### 영속성 컨텍스트(persistence context)
엔티티를 영구적으로 저장하는 환경
엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리
엔티티 매니저를 생성할 때 하나 만들어지며, 엔티티 매니저를 통해 접근 및 관리

### 엔티티 생명주기
1. 비영속(new/transient) : 영속성 컨텍스트와 관계가 없는 상태
2. 영속(managed) : 영속성 컨텍스트에 저장된 상태
3. 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
4. 삭제(removed) : 삭제된 상태

비영속 : 엔티티 객체를 생성하고 저장하기 전
영속 : 엔티티 매니저를 통해 영속성 컨텍스트에 저장한 엔티티 또는 조회한 엔티티
준영속 : 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않을 때 (em.detach(), em.close(), em.clear())
삭제 : 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제 em.remove()

### 영속성 컨텍스트 특징
- 영속성 컨텍스트와 식별자 값
@Id 어노테이션을 통해 테이블의 기본 키와 매핑한 값으로 구분
반드시 필요 없을시 예외
- 영속성 컨텍스트와 데이터베이스 저장
영속성 컨텍스트에 엔티티를 저장하면 트랜잭션이 커밋되는 순간 데이터베이스에 반영 -> 플러시(flush)
- 영속성 컨텍스트가 엔티티를 관리했을 때의 장점
1차캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경 감지, 지연 로딩

#### 1차 캐시
영속성 컨텍스트 내부에 가지고 있는 캐시
영속 상태의 엔티티가 저장됨
em.find()를 호출했을 때 1차 캐시에서 먼저 엔티티를 찾고 없으면 데이터베이스에서 조회 -> 엔티티 생성 -> 1차 캐시 저장 -> 영속상태의 엔티티 반환
성능상 이점과 동일성(참조 값이 같음)을 보장
REPEATABLE READ 격리 수준을 애플리케이션 차원에서 보장

#### 쓰기 지연(tranactional write-behind)
엔티티 매니저가 트랜잭션 내에서 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 모아놓다가 커밋할 때 데이터베이스에 보내는 것

#### 변경 감지(dirty checking)
memberA.setUserName(“hi”);
memberA.setAge(10);
이후 커밋하면 데이터베이스에 반영됨

JPA에서 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장 -> 스냅샷
플러시 시점에 스냅샷과 엔티티를 비교 -> 변경되었는지 알 수 있음
단, 영속 상태의 엔티티에만 적용
JPA는 기본 전략으로 UPDATE 문은 수정된 데이터만 반영하는 것이 아니라 모든 필드를 반영 -> 미리 만들어둔 수정 쿼리의 재활용을 위해서 (모든 update에 같은 쿼리이므로)
@DynamicUpdate 어노테이션으로 수정된 데이터만 동적으로 생성할 수 있음
컬럼이 30개 이상인 경우 동적 수정 쿼리가 빠를 수 있지만 이런 경우 설계가 잘못되있을 가능성이 높음

### 플러시(flush)
영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것

#### 플러시 동작과정
1. 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교하여 수정된 엔티티를 찾음 (변경 감지)
2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제)

#### 플러시 호출 방법
- 직접 호출
엔티티 매니저의 flush() 메서드를 직접 호출해서 영속성 컨텍스트를 강제로 플러시
- 트랜잭션 커밋시 자동 호출
데이터베이스를 커밋하기 전에 플러시를 자동으로 호출
- JPQL 쿼리 실행시 플러시 자동 호출
객체지향 쿼리 호출시 자동 실행
JPQL을 통해 실제 쿼리를 조회하는데 영속성 컨텍스트에만 있는 엔티티가 있다면 결과가 달라질 수 있기 때문


### 준영속
영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것
영속성 컨텍스트가 제공하는 기능을 사용할 수 없음
1. detach() : 엔티티를 준영속 상태로 전환
1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거
2. clear() : 영속성 컨텍스트 초기화
해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만듬
1차 캐시와 쓰기 지연 SQL 저장소를 모두 비움
3. close() : 영속성 컨텍스트 종료
영속성 컨텍스트를 종료시켜 해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만듬

#### 준영속 상태인 경우
- 비영속 상태에 가까움
1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩 포함한 영속성 컨텍스트 제공 기능이 동작하지 않음
- 식별자 값 존재
비영속 상태에서는 식별자 값이 없을 수 있지만 준영속 상태는 반드시 식별자 값이 있음
- 지연 로딩 불가
실제 객체 대신 프록시 객체를 로딩해두고, 해당 객체가 사용될 때 영속성 컨텍스트를 통해 데이터를 불러오는 기능인 지연 로딩 사용 불가

4. merge() : 병합
준영속 상태의 엔티티의 정보로 새로운 영속 상태의 엔티티를 반환 (영속상태로 변경)
비영속 상태의 엔티티도 가능 (save or update 기능)

## 엔티티 매핑
### @Entity
JPA를 사용해 테이블과 매핑할 클래스에 필수로 붙여야 하는 어노테이션
다른 패키지에 같은 클래스명의 엔티티가 있으면 name 속성을 변경해야함
JPA가 엔티티 객체를 생성할 때 기본 생성자를 사용하므로 반드시 있어야 함 (public, protected)
저장할 필드에 final 사용 불가 

### @Table
엔티티와 매핑할 테이블 지정

### @Id
직접 할당 : 애플리케이션에서 직접 할당 없을 시 예외 발생
자동 생성 : @GeneratedValue 추가 이후 키 생성 전략 선택
IDENTITY : 기본 키 생성을 데이터베이스에 위임
SEQUENCE : 데이터베이스 시퀀스를 사용 (Oracle, PostgreSQL, DB2, H2)
TABLE : 키 생성 테이블 사용
AUTO : 위 세 방식 중 하나를 자동으로 선택 (개발초기)

### 필드와 컬럼 매핑
#### @Column
객체 필드를 테이블 컬럼에 매핑
name : 컬럼명
nullable : null 값의 허용 여부
unique : 유니크 제약조건 (두 컬럼 이상은 @Table.uniqueConstraints 사용)
length : 문자열 길이
precision : BigDecimal 총 자리 수
scale : BigDecimal 소수점 자리 수 

#### @Enumerated
자바 enum 타입 매핑
value 속성 : 어떤 값을 데이터베이스에 저장할지
EnumType.ORDINAL : enum 순서 저장
EnumType.STRING : enum 이름 저장

#### @Temporal
날짜 타입 매핑

#### @Lob
BLOB, CLOB 타입 매핑
필드 타입 문자면 CLOB
나머지는 BLOB

#### @Transient
매핑하지 않는 컬럼

#### @Access
JPA가 엔티티 데이터에 접근하는 방식 
AccessType.FIELD : 필드에 직접 접근
AccessType.PROPERTY : 접근자를 사용한 접근(Getter)

## 연관관계 매핑
객체는 참조(주소)로 연관관계를 맺음
테이블은 외래 키로 연관관계를 맺음

방향 (단방향 : 한쪽만 참조, 양방향 : 양쪽에서 서로 참조)
다중성 : 다대일, 일대다, 일대일, 다대다
연관관계 주인 : 객체가 양방향 연관관계인 경우 연관관계의 주인을 정해야함

### 단방향 연관관계
#### 다대일(N:1) 단방향 관계
회원(N) -> 팀(1)
회원 테이블에 팀 아이디(FK)가 존재
회원 엔티티에 @ManyToOne, @JoinColumn(name=“FK컬럼명”) 팀 엔티티 추가

@ManyToOne 속성
optional : 연관된 엔티티가 항상 필요한지
fetch : 글로벌 페치 전략
cascade : 영속성 전이 기능

##### 조회방법
1. 객체 그래프 탐색 (객체 연관관계를 사용한 조회)
member.getTeam()
2. 객체지향 쿼리(JPQL) 사용
select m from Member m join m.team t where t.name=:teamName

#### 다대일(N:1) 양방향 관계
팀 엔티티에 @OneToMany(mappedBy = “team”) List<Member> 추가
mappedBy 속성은 반대쪽 매핑의 필드명
양방향 관계에서 외래키를 어떤 테이블에서 관리할지 -> 연관관계의 주인
연관관계의 주인만이 외래키를 관리할 수 있음
mappedBy 속성으로 주인을 지정함 (mappedBy가 있으면 주인이 아닌 것)

양방향 관계일때 관계를 변경하는 경우 (setTeam())

// 주인이 아닌쪽에도 기존 관계를 제거해줌
if (this.team != null) {
	this.team.getMembers().remove(this);
}
// 주인이 아닌쪽에도 새로운 관계를 설정해줌
this.team.getMembers().add(this);

toString() 등의 메서드 호출시에 무한 루프 주의해야함
ex) Member.toString()에서 getTeam()을 호출하고 
Team.toString()에서 getMember()를 호출하는 경우

#### 일대다(1:N) 단방향 관계
@JoinColumn을 명시하지 않으면 연결 테이블을 중간에 두고 관리하는 JoinTable 전략을 기본으로 사용
매핑한 객체가 관리하는 외래키가 다른 테이블에 있기 때문에 엔티티를 저장할 때 연관관계 처리를 위한 UPDATE SQL이 추가적으로 실행되야 함

#### 일대다(1:N) 양방향 관계
존재하지 않음
@OneToMany 는 연관관계 주인이 불가
@ManyToOne에는 mappedBy가 없음
구현하려면 일대다 단방향 관계에서 반대편에 다대일 단방향을 읽기 전용으로 추가

#### 일대일(1:1)
