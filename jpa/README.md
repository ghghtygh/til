# JPA
#TIL/JPA

## JPA
### JPA(Java Persistence API)
자바 진영의 ORM 기술 표준
애플리케이션과 JDBC 사이에서 동작

### ORM (Object-Relational Mapping)
객체와 관계형 데이터베이스를 매핑하는 것
자바 컬렉션에 저장하듯이 ORM 프레임워크에 저장하면 INSERT SQL을 생성하여 DB에 객체를 저장해줌
데이터 중심인 RDBMS를 사용해도 객체지향 어플리케이션 개발에 집중할 수 있음

### JPA 장점
CRUD SQL과 같은 반복적인 코드를 직접 작성하지 않아도 되며, DDL문 생성 등 JPA가 대신 처리해주는 기능이 많아 생산성이 좋음
SQL문을 직접 작성하게 되면 엔티티 변경에 따라 변경되어야 하는 코드 수가 많지만, JPA를 사용하면 유지보수해야하는 코드 수가 줄어듬
상속, 연관관계, 객체 그래프 탐색, 비교 등의 패러다임 불일치 문제 해결
애플리케이션과 데이터베이스 사이에 위치하여 성능 최적화 기회 제공
데이터 접근 추상화에 따라 특정 데이터베이스 기술에 종속되지 않는 벤더 독립성

### JPQL(Java Persistence Query Language)
JPA에서 제공하는, SQL을 추상화한 객체지향 쿼리 언어
SQL의 문법을 사용하지만 엔티티 객체(클래스, 필드)를 대상으로 쿼리

## 엔티티 매니저 팩토리(EntityManagerFactory)
JPA에서 제공하는 기능의 분류
- 엔티티와 테이블을 매핑하는 설계하는 부분
- 매핑한 엔티티를 실제로 사용하는 부분 -> 엔티티 매니저(Entity Manager)

엔티티 매너지 팩토리를 통해 엔티티 매니저를 생성 (저비용)

엔티티 매니저는 데이터베이스 연결이 필요한 시점(보통 트랜잭션 시작시점)에 커넥션을 획득

### 영속성 컨텍스트(persistence context)
엔티티를 영구적으로 저장하는 환경
엔티티 매니저로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리
엔티티 매니저를 생성할 때 하나 만들어지며, 엔티티 매니저를 통해 접근 및 관리

### 엔티티 생명주기
1. 비영속(new/transient) : 영속성 컨텍스트와 관계가 없는 상태
2. 영속(managed) : 영속성 컨텍스트에 저장된 상태
3. 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태
4. 삭제(removed) : 삭제된 상태

비영속 : 엔티티 객체를 생성하고 저장하기 전
영속 : 엔티티 매니저를 통해 영속성 컨텍스트에 저장한 엔티티 또는 조회한 엔티티
준영속 : 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않을 때 (em.detach(), em.close(), em.clear())
삭제 : 엔티티를 영속성 컨텍스트와 데이터베이스에서 삭제 em.remove()

### 영속성 컨텍스트 특징
- 영속성 컨텍스트와 식별자 값
@Id 어노테이션을 통해 테이블의 기본 키와 매핑한 값으로 구분
반드시 필요 없을시 예외
- 영속성 컨텍스트와 데이터베이스 저장
영속성 컨텍스트에 엔티티를 저장하면 트랜잭션이 커밋되는 순간 데이터베이스에 반영 -> 플러시(flush)
- 영속성 컨텍스트가 엔티티를 관리했을 때의 장점
1차캐시, 동일성 보장, 트랜잭션을 지원하는 쓰기 지연, 변경 감지, 지연 로딩

#### 1차 캐시
영속성 컨텍스트 내부에 가지고 있는 캐시
영속 상태의 엔티티가 저장됨
em.find()를 호출했을 때 1차 캐시에서 먼저 엔티티를 찾고 없으면 데이터베이스에서 조회 -> 엔티티 생성 -> 1차 캐시 저장 -> 영속상태의 엔티티 반환
성능상 이점과 동일성(참조 값이 같음)을 보장
REPEATABLE READ 격리 수준을 애플리케이션 차원에서 보장

#### 쓰기 지연(tranactional write-behind)
엔티티 매니저가 트랜잭션 내에서 데이터베이스에 엔티티를 저장하지 않고 내부 쿼리 저장소에 모아놓다가 커밋할 때 데이터베이스에 보내는 것

#### 변경 감지(dirty checking)
memberA.setUserName(“hi”);
memberA.setAge(10);
이후 커밋하면 데이터베이스에 반영됨

JPA에서 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장 -> 스냅샷
플러시 시점에 스냅샷과 엔티티를 비교 -> 변경되었는지 알 수 있음
단, 영속 상태의 엔티티에만 적용
JPA는 기본 전략으로 UPDATE 문은 수정된 데이터만 반영하는 것이 아니라 모든 필드를 반영 -> 미리 만들어둔 수정 쿼리의 재활용을 위해서 (모든 update에 같은 쿼리이므로)
@DynamicUpdate 어노테이션으로 수정된 데이터만 동적으로 생성할 수 있음
컬럼이 30개 이상인 경우 동적 수정 쿼리가 빠를 수 있지만 이런 경우 설계가 잘못되있을 가능성이 높음

### 플러시(flush)
영속성 컨텍스트의 변경 내용을 데이터베이스에 반영하는 것

#### 플러시 동작과정
1. 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교하여 수정된 엔티티를 찾음 (변경 감지)
2. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송 (등록, 수정, 삭제)

#### 플러시 호출 방법
- 직접 호출
엔티티 매니저의 flush() 메서드를 직접 호출해서 영속성 컨텍스트를 강제로 플러시
- 트랜잭션 커밋시 자동 호출
데이터베이스를 커밋하기 전에 플러시를 자동으로 호출
- JPQL 쿼리 실행시 플러시 자동 호출
객체지향 쿼리 호출시 자동 실행
JPQL을 통해 실제 쿼리를 조회하는데 영속성 컨텍스트에만 있는 엔티티가 있다면 결과가 달라질 수 있기 때문


### 준영속
영속성 컨텍스트가 관리하는 영속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것
영속성 컨텍스트가 제공하는 기능을 사용할 수 없음
1. detach() : 엔티티를 준영속 상태로 전환
1차 캐시부터 쓰기 지연 SQL 저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거
2. clear() : 영속성 컨텍스트 초기화
해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만듬
1차 캐시와 쓰기 지연 SQL 저장소를 모두 비움
3. close() : 영속성 컨텍스트 종료
영속성 컨텍스트를 종료시켜 해당 영속성 컨텍스트의 모든 엔티티를 준영속 상태로 만듬

#### 준영속 상태인 경우
- 비영속 상태에 가까움
1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩 포함한 영속성 컨텍스트 제공 기능이 동작하지 않음
- 식별자 값 존재
비영속 상태에서는 식별자 값이 없을 수 있지만 준영속 상태는 반드시 식별자 값이 있음
- 지연 로딩 불가
실제 객체 대신 프록시 객체를 로딩해두고, 해당 객체가 사용될 때 영속성 컨텍스트를 통해 데이터를 불러오는 기능인 지연 로딩 사용 불가

4. merge() : 병합
준영속 상태의 엔티티의 정보로 새로운 영속 상태의 엔티티를 반환 (영속상태로 변경)
비영속 상태의 엔티티도 가능 (save or update 기능)

## 엔티티 매핑
### @Entity
JPA를 사용해 테이블과 매핑할 클래스에 필수로 붙여야 하는 어노테이션
다른 패키지에 같은 클래스명의 엔티티가 있으면 name 속성을 변경해야함
JPA가 엔티티 객체를 생성할 때 기본 생성자를 사용하므로 반드시 있어야 함 (public, protected)
저장할 필드에 final 사용 불가 

### @Table
엔티티와 매핑할 테이블 지정

### @Id
직접 할당 : 애플리케이션에서 직접 할당 없을 시 예외 발생
자동 생성 : @GeneratedValue 추가 이후 키 생성 전략 선택
IDENTITY : 기본 키 생성을 데이터베이스에 위임
SEQUENCE : 데이터베이스 시퀀스를 사용 (Oracle, PostgreSQL, DB2, H2)
TABLE : 키 생성 테이블 사용
AUTO : 위 세 방식 중 하나를 자동으로 선택 (개발초기)

### 필드와 컬럼 매핑
#### @Column
객체 필드를 테이블 컬럼에 매핑
name : 컬럼명
nullable : null 값의 허용 여부
unique : 유니크 제약조건 (두 컬럼 이상은 @Table.uniqueConstraints 사용)
length : 문자열 길이
precision : BigDecimal 총 자리 수
scale : BigDecimal 소수점 자리 수 

#### @Enumerated
자바 enum 타입 매핑
value 속성 : 어떤 값을 데이터베이스에 저장할지
EnumType.ORDINAL : enum 순서 저장
EnumType.STRING : enum 이름 저장

#### @Temporal
날짜 타입 매핑

#### @Lob
BLOB, CLOB 타입 매핑
필드 타입 문자면 CLOB
나머지는 BLOB

#### @Transient
매핑하지 않는 컬럼

#### @Access
JPA가 엔티티 데이터에 접근하는 방식 
AccessType.FIELD : 필드에 직접 접근
AccessType.PROPERTY : 접근자를 사용한 접근(Getter)

## 연관관계 매핑
객체는 참조(주소)로 연관관계를 맺음
테이블은 외래 키로 연관관계를 맺음

방향 (단방향 : 한쪽만 참조, 양방향 : 양쪽에서 서로 참조)
다중성 : 다대일, 일대다, 일대일, 다대다
연관관계 주인 : 객체가 양방향 연관관계인 경우 연관관계의 주인을 정해야함

### 단방향 연관관계
#### 다대일(N:1) 단방향 관계
회원(N) -> 팀(1)
회원 테이블에 팀 아이디(FK)가 존재
회원 엔티티에 `@ManyToOne` `@JoinColumn(name=“FK컬럼명”)`  추가

@ManyToOne 속성
optional : 연관된 엔티티가 항상 필요한지
fetch : 글로벌 페치 전략
cascade : 영속성 전이 기능

##### 조회방법
1. 객체 그래프 탐색 (객체 연관관계를 사용한 조회)
member.getTeam()
2. 객체지향 쿼리(JPQL) 사용
select m from Member m join m.team t where t.name=:teamName

#### 다대일(N:1) 양방향 관계
팀 엔티티에 `@OneToMany(mappedBy = “team”) List<Member>` 추가
mappedBy 속성은 반대쪽 매핑의 필드명
양방향 관계에서 외래키를 어떤 테이블에서 관리할지 -> 연관관계의 주인
연관관계의 주인만이 외래키를 관리할 수 있음
mappedBy 속성으로 주인을 지정함 (mappedBy가 있으면 주인이 아닌 것)

양방향 관계일때 관계를 변경하는 경우 (setTeam())

// 주인이 아닌쪽에도 기존 관계를 제거해줌
if (this.team != null) {
	this.team.getMembers().remove(this);
}
// 주인이 아닌쪽에도 새로운 관계를 설정해줌
this.team.getMembers().add(this);

toString() 등의 메서드 호출시에 무한 루프 주의해야함
ex) Member.toString()에서 getTeam()을 호출하고 
Team.toString()에서 getMember()를 호출하는 경우

#### 일대다(1:N) 단방향 관계
@JoinColumn을 명시하지 않으면 연결 테이블을 중간에 두고 관리하는 JoinTable 전략을 기본으로 사용
매핑한 객체가 관리하는 외래키가 다른 테이블에 있기 때문에 엔티티를 저장할 때 연관관계 처리를 위한 UPDATE SQL이 추가적으로 실행되야 함

#### 일대다(1:N) 양방향 관계
존재하지 않음
@OneToMany 는 연관관계 주인이 불가
@ManyToOne에는 mappedBy가 없음
구현하려면 일대다 단방향 관계에서 반대편에 다대일 단방향을 읽기 전용으로 추가

#### 일대일(1:1)
양쪽이 서로 하나의 관계 (반대도 일대일 관계)
주 테이블이나 대상 테이블 중 어느 곳이나 외래키 가질 수 있음

- 주 테이블 외래키
외래키를 객체 참조와 비슷하게 사용 (객체지향적)
주 테이블만 확인해도 대상 테이블과 연관관계 여부를 알 수 있음

- 대상 테이블 외래키
전통적인 데이터베이스 방식
테이블 관계를 일대다로 변경하더라도 테이블 구조 유지 가능

#### 일대일(1:1) 주 테이블 외래키
다대일 관계와 비슷

- 단방향 관계
주 테이블 엔티티에 `@OneToOne` `@JoinColumn(name="외래키명")`추가 

- 양방향 관계
대상 테이블 엔티티에 `@OneToOne(mappedBy = "대상테이블엔티티명")` 추가


#### 일대일(1:1) 대상 테이블 외래키

-  단방향 관계
JPA에서 대상 테이블 외래키 단방향은 따로 지원하지 않음
양방향 관계로 만든 후, 대상 테이블을 연관관계의 주인으로 설정

- 양방향 관계
주 테이블 엔티티에 `@OneToOne(mappedBy="주테이블엔티티명")` 추가
대상 테이블 엔티티에 `@OneToOne` `@JoinColumn(name="외래키명")`추가 


#### 다대다(N:N)
DB에서는 중간에 연결 테이블을 추가해서 일대다, 다대일 관계로 풀어냄

##### @ManyToMany 사용
객체 2개로 다대다 관계를 만들 수 있음
도메인 모델이 단순해짐

- 단방향 관계
주 테이블 엔티티에 `@ManyToMany` `@JoinTable(name=“연결 테이블명”, joinColumns=@JoinColumn(name="대상테이블ID컬럼명"), inverseJoinColumns=@JoinColumn(name="주테이블ID컬럼명"))` 추가

@JoinTable : 연결 테이블 매핑
@JoinTable.name : 연결 테이블 지정
@JoinTable.joinColumns : 주 테이블과 매핑할 조인 컬럼 정보
@JoinTable.inverseJoinColumns : 대상 테이블에 매핑할 조인 컬럼 정보

- 양방향 관계
대상 테이블 엔티티에 `@ManyToMany(mappedBy="대상테이블엔티티명")` 추가

@ManyToMany를 사용하면 도메인 모델이 단순해지지만, 연결 테이블에 데이터가 등록된 일시, 등록한 수량 등 부가적인 정보를 담을 수 없음 -> 다른 방식 필요

##### 연결 엔티티 사용 - 복합 기본키 (식별관계)
주 테이블 엔티티에 `@OneToMany(mappedBy="주테이블엔티티명")` 추가

연결 테이블 엔티티 생성 후 
연결 테이블 엔티티 class 선언부에 `@IdClass(연결엔티티.class)` 추가
주 테이블 엔티티  `@Id` `@ManyToOne` `@JoinColumn(name="주테이블ID컬럼명")` 추가
대상 테이블 엔티티  `@Id` `@ManyToOne` `@JoinColumn(name="대상테이블ID컬럼명")` 추가

###### 복합 기본 키 사용 조건
- 복합 키를 별도의 식별자 클래스로 생성 (`@IdClass` or `@EmbeddedId`)
- `Serializable` 인터페이스 구현
- `equals()`, `hashCode()` 메서드 구현
- 기본 생성자 필요
- 식별자 클래스 public 선언


##### 연결 엔티티 사용 - 새로운 기본키 (비식별관계)
다대다 관계의 ORM 매핑 시에 복합 키를 만들지 않고 DB에서 생성하는 대리 키를 연결 엔티티의 ID로 사용

- 아이디 컬럼 `@Id`, `@GeneratedValue` 추가
- 주 테이블 엔티티 `@ManyToOne`, `@JoinColumn(name=“주테이블ID컬럼”)` 추가
- 대상 테이블 엔티티 `@ManyToOne`, `@JoinColumn(name=“대상테이블ID컬럼”)` 추가

객체 입장에서 복합 키를 위한 식별자 클래스를 만들지 않아도 되므로 ORM 매핑이 단순해지기 때문에 비식별 관계를 추천

## 상속 관계 매핑
ORM의 상속관계 매핑은 객체의 상속 구조와 데이터베이스의 슈퍼타입 서브타입 관계를 매핑하는 것
- 각각 테이블로 변환 (조인 전략)
- 통합 테이블로 변환 (단일 테이블 전략)
- 서브타입 테이블로 변환 (서브타입마다 한 테이블)

#### 조인 전략(Joined Strategy)
상속관계에 있는 부모 자식 엔티티 각각을 테이블로 생성한 뒤, 자식 테이블이 부모 테이블의 기본키를 받아 조인하여 조회하는 방식

장점
테이블이 정규화
외래키 참조 무결성 제약조건 활용
저장공간 효율적

단점
조회할 때 성능 저하
조회 쿼리가 복잡해짐
INSERT 문 두번 필요

#### 단일 테이블 전략(Single-Table Strategy)
테이블을 하나만 사용하고, 구분 컬럼을 두어 어떤 객체의 데이터가 저장되었는지 구분하는 방식

장점
조회 성능이 빠름
조회 쿼리가 단순

단점
자식 엔티티가 매핑한 컬럼은 모두 null 허용해야 함
테이블 크기가 커지기 때문에 상황에 따라서는 조회 성능이 오히려 느려짐

#### 구현 클래스마다 테이블 전략(Table-per-Concrete-Class Strategy)
자식 엔티티마다 테이블을 생성하는 방식
일반적으로는 추천되지 않음

장점
서브 타입을 구분해서 처리할 때 효과적
not null 제약조건을 사용할 수 있음

단점
여러 자식 테이블을 함께 조회할 때 성능이 느림 (UNION)
자식 테이블을 통합해서 쿼리하기 어려움

### @MappedSuperclass
부모 클래스는 테이블과 매핑하지 않고, 자식 클래스에게 매핑 정보만 제공할 때 사용
추상 클래스로 만드는 것을 권장
등록일시, 등록자 아이디 등 공통으로 사용하는 속성을 효과적으로 관리

### 식별관계 매핑 
#### 식별 관계(Identifying Relationship)
부모 테이블의 기본키를 자식 테이블의 외래 키로 사용하면서, 기본키로 사용
부모 테이블의 기본키를 자식 테이블로 전파하기 때문에 기본 키 컬럼이 점점 늘어남
기본 키 인덱스를 활용하기 좋고, 특정 상황에서는 조인 없이 검색이 가능한 경우도 있음
추천되지는 않음

#### 비식별 관계(Non-Identifying Relationship)
부모 테이블의 기본키를 자식 테이블의 외래키로만 사용
자식 테이블의 기본키로는 대리키를 사용
- 필수적 비식별 관계(Mandatory) : 외래키에 NULL 허용 안함
- 선택적 비식별 관계(Optional) : 외래키에 NULL 허용

### @SecondaryTable
한 엔티티에 여러 테이블을 매핑할 때 사용

## 프록시
지연 로딩 : 연관된 엔티티가 실제 사용될 때까지 DB 조회를 지연하는 것 (사용하지 않을수도 있으므로)
지연로딩을 사용하기 위해 실제 연관된 엔티티 객체 대신 가짜 객체(프록시 객체)가 필요
(바이트 코드를 수정하는 방법도 있음)

### 프록시 객체 동작원리
JPA에서 식별자로 엔티티 하나를 조회하는 경우 `EntityManager.find()` 를 이용
엔티티를 실제 사용하는 시점까지 DB 조회를 미루기 위해서는 `EntityManager.getReference()` 메서드를 사용하여 프록시 객체를 조회
프록시 객체는 실제 객체에 대한 참조(target)를 보관
그러다 호출되어 실제 사용될 때 DB 조회하여 실제 엔티티 객체를 생성 (프록시 객체 초기화)

### 프록시 객체 특징
프록시 객체는 처음 사용될 때 한번만 초기화
프록시 객체가 초기화되면 실제 엔티티가 되는 것은 아니지만 프록시를 통해 실제 엔티티에 접근
프록시 객체는 원본 엔티티를 상속받은 것이기 떄문에 타입 체크시에 주의
영속성 컨텍스트에 찾는 엔티티가 이미 있는 경우 `em.getRefrence()` 메서드 호출 시 실제 엔티티를 반환
프록시 객체 초기화는 영속성 컨텍스트가 필요 (준영속 상태 프록시 초기화시 예외 발생)

`@Access(AccessType.PROPERTY))` : 엔티티 접근방식을 프로퍼티로 설정 -> 식별자 값을 조회해도 프록시가 초기화 되지 않음
`@Access(AccessType.FIELD))` : 엔티티 접근방식을 필드로 설정 -> 식별자 값을 조회해도 프록시 객체를 초기화

JPA에서 제공되는 `PersistenceUnitUtil.isLoaded(Object entity)` 메서드를 사용하여 프록시 인스턴스의 초기화 여부를 확인

### 즉시 로딩(EAGER LOADING)
@ManyToOne의 fetch 속성을 FetchType.EAGER로 지정
가능하면 조인을 이용하여 한번에 조회 (nullable, optional에 따라 외부조인, 내부조인 결정)

### 컬렉션 래퍼
하이버네이트에서 엔티티를 영속상태로 만들 때 컬렉션이 있는 경우 추적을 위해 변경하는 하이버네이트 내장 컬렉션
엔티티의 지연로딩시 컬렉션의 경우 컬렉션 래퍼가 지연 로딩을 처리 (컬렉션에 대한 프록시 역할 수행)

### JPA 기본 페치 전략
@ManyToOne, @OneToOne : 즉시 로딩
@OneToMany, @ManyToMany : 지연 로딩

### 영속성 전이(transitive persistence) : CASCADE
특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만드는 기능
JPA에서 CASECADE 옵션을 통해 영속성 전이를 제공
CascadeType.ALL : 모두 적용
CascadeType.PERSIST : 영속
CascadeType.MERGE : 병합
CascadeType.REMOVE : 삭제
CascadeType.REFRESH : 연관 엔티티도 새로 고침
CascadeType.DETACH : detach() 수행시 연관 엔티티도 detach()

### 고아 객체(ORPHAN)
부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제하는 기능
orphanRemoval = true 옵션인 경우 연관 객체 컬렉션에서 remove() 되어 참조되지 않을 때 추후 DELETE 됨
@OneToOne, @OneToMany에서만 사용 가능 (다른 곳에서 참조하게 되면 문제 발생)

## JPA 데이터 타입
- 엔티티 타입 : @Entity로 정의, 식별자와 생명주기가 있음
- 값 타입 : 식별자가 없음, 생명주기를 엔티티에 의존
	- 기본 값 타입
		- 자바 기본 타입
		- 래퍼 클래스
		- String
	- 임베디드 타입(복합 값 타입)
	- 컬렉션 값 타입

### 임베디드 타입(복합 값 타입)
JPA에서 사용자가 직접 정의한 새로운 값 타입
`@Embeddable` 로 정의, `@Embedded` 로 사용
하이버네이트에서는 컴포넌트(components)라고 함

```
@Entity
public class User {
	@Id @GeneratedValue
	private Long id;
	// ...
	@Embedded Period workPeriod;
	@Embedded Address workAddress;
	// ...
}

@Embeddable
public class Period {
	//...
}
```

`@AttributeOverride` 속성으로 매핑정보를 재정의할 수 있음

### 공유 참조
임베디드 타입 등의 값 타입을 여러 엔티티에서 공유해서 참조하게 되면 다른 레코드도 예기치 못하게 변경될 수 있음 (side effect)
이런 경우 값 타입을 복사(clone())하여 새로운 값을 생성해야 함
근본적으로 막기 위해서 setter 등의 수정자 메서드를 제거

### 불변 객체(Immutable Object)
값 타입을 부작용 없이 사용할 수 있도록 하기 위해서 불변 객체로 설계
생성자로만 값을 설정하고, 수정자를 만들지 않음

### 값 타입 비교
== : 동일성(Identity) 비교 - 인스턴스의 참조 값 비교
equals() : 동등성(Equivalence) 비교 - 인스턴스의 값 비교


## 객체지향 쿼리
### JPQL(Java Persistence Query Language)
엔티티 객체를 대상으로 검색하는 객체지향 쿼리
SQL을 추상화하여 특정 DB SQL에 의존하지 않음
ANSI 표준 SQL이 제공하는 기능을 유사하게 지원
위치 기준 파라미터 바운딩 뿐만 아니라 이름 기준 파라미터 바운딩 지원

#### TypeQuery, Query
TypeQuery : 반환 타입 명확하게 지정 가능
Query : 반환타입 명확하게 지정 불가 (Object, Object[] 반환)

#### 프로젝션(projection)
SELECT 절에 조회할 대상을 지정하는 것(엔티티, 임베디드 타입, 스칼라 타입)
프로젝션에 여러 값을 선택하면 TypeQuery 사용불가 
SELECT 문에서 NEW 명령어를 사용하여 반환받을 클래스를 지정할 수 있음
(패키지 포함한 전체 클래스명, 순서 및 타입이 일치하는 생성자 필요)

#### 페이징 API
setFirstResults() : 조회 시작 위치
setMaxResult() : 조회할 데이터 수

MySQL의 경우 limt 0, 10

#### 조인
##### 내부조인
```
SELECT m, t
FROM Member m JOIN m.team t
WHERE t.name = 'A팀'
```

```
List<Object[]> result = em.createQuery(query).getResultList();
for(Object[] row : result) {
	Member member = (Member) row[0];
	Team team = (Team) row[1];
}
```

##### 외부조인
```
SELECT m, t
FROM Member m LEFT JOIN m.team t
```


##### 세타조인
WHERE 절을 이용해서 전혀 관계 없는 엔티티도 조인 가능 (내부 조인만 지원)
```
select count(m) from Member m, Team t
where m.username= t.name
```

##### JOIN ON 절 (JPA2.1)
JPA 2.1부터 조인할 때 ON 절을 지원
조인 시점에 조인 대상을 필터링할 때 사용
내부 조인에서는 WHERE 절의 결과와 같으므로 외부 조인에서만 사용

##### 페치(fetch) 조인
JPQL에서 성능 최적화를 위해 제공하는 기능
연관된 엔티티나 컬렉션을 같이 조회하는 기능
join fetch 명령어로 사용

###### 엔티티 페치 조인
select m from Member m join fetch m.team

###### 컬렉션 페치 조인
일대다 관계인 컬렉션을 페치 조인
```
select t from Team t join fetch t.members
where t.name = ‘A팀’
```

팀에 연관된 회원을 함께 조회했기 때문에 결과는 A팀에 해당하는 회원 건수만큼 조회됨

###### 페치 조인 DISTINCT
JPQL에서 DISTINCT 명령어는 SQL에 DISTINCT를 추가하면서 애플리케이션에서 중복을 한번 더 제거

페치 조인 특징
- 페치 조인을 사용하지 않으면 연관객체는 조회하지 않고 프록시 또는 초기화되지 않은 컬렉션 래퍼를 반환
- 페치 조인을 사용하면 글로벌 로딩 전략보다 우선됨
- 글로벌 로딩 전략은 지연 로딩을 사용하고 필요한 경우 페치 조인을 적용하는 것이 효과적
- 페치조인을 사용하면 엔티티를 쿼리 시점에 조회하므로 지연 로딩이 발생하지 않고, 준영속 상태에서도 객체 그래프 탐색 가능

페치조인 단점
- JPA 표준에서는 페치 조인 대상에는 별칭 지정 불가, 구현체에서 별칭을 지정하게 되면 2차 캐시와 함께 사용할 떄 연관된 데이터 수가  달라질 수 있어 조심해야 함
- 둘 이상의 컬렉션을 페치할 수 없음, 구현체에 따라 될 수 있지만 컬렉션 * 컬렉션의 카테시안 곱이 만들어지므로 유의 필요
- 컬렉션을 페치 조인하는 경우 페이징 API 사용 불가

###### 경로 탐색
묵시적 조인
- 경로 표현식에 의해 묵시적으로 일어나는 조인
- 항상 내부 조인으로 발생
- 컬렉션에서는 경로 탐색 불가

명시적 조인 
JOIN을 명시하는 것

###### 서브 쿼리
WHERE, HAVING 절에서만 사용 가능


### Criteria
JPQL을 생성하는 빌더 클래스
프로그래밍 코드로 JPQL을 작성할 수 있음
컴파일 시점에 오류 발견 가능
IDE를 사용한 코드 자동완성 지원
동적 쿼리 작성하기 편함

메타 모델(MetaModel) API
엔티티 클래스로부터 Criteria 전용 클래스를 생성하여 필드명을 코드로 작성 가능

### QueryDSL
Criteria 처럼 JPQL의 필더 역할
코드 기반이면서 단순하고 사용하기 쉬움

### 네이티브 SQL
SQL을 직접 사용할 수 있도록 JPA에서 지원하는 기능
특정 DB에 의존하는 SQL을 작성하게 될 수 있음

### JDBC 직접 사용
- JDBC Connecion을 직접 획득하여 사용
EntityManager에서 하이버네이트 Session을 구한 뒤, doWork() 메서드 호출
- MyBatis 같은 SQL 매퍼 프레임워크를 사용

영속성 컨텍스트와 데이터베이스가 불일치 상태가 될 수 있으므로 적절한 시점에 강제로 플러시해야함








## 트랜잭션 범위의 영속성 컨텍스트
### 스프링 컨테이너 기본 전략
트랜잭션 범위의 영속성 컨텍스트 전략
트랜잭션 범위와 영속성 컨텍스트 생존 범위가 같음
같은 트랜잭션에서는 항상 같은 영속성 컨텍스트에 접근
@Transactional 어노테이션으로 트랜잭션을 시작
이 때 트랜잭션 AOP는 대상 메서드를 호출하기 직전에 시작하고, 커밋하면서 종료됨
커밋되기 전에 먼저 영속성 컨텍스트를 플러시해서 변경 내용을 DB에 반영하고, 트랜잭션을 커밋함
트랜잭션이 롤백되는 경우 플러시를 호출하지 않음

- 트랜잭션이 같으면 같은 영속성 컨텍스트를 사용
- 트랜잭션이 다르면 다른 영속성 컨텍스트를 사용

### 준영속 상태와 지연 로딩
기본 전략의 트랜잭션 범위 영속성 컨텍스트 전략을 사용하면 트랜잭션이 없는 프레젠테이션 계층에서의 엔티티는 준영속 상태임
-> 변경 감지, 지연 로딩 동작하지 않음

준영속 상태의 지연로딩 문제 해결 방법
- 뷰가 필요한 엔티티를 미리 로딩
	- 글로벌 페치 전략 수정
		- 즉시 로딩으로 설정 : 사용하지 않는 엔티티를 로딩하게 됨, N+1 문제가 발생
	- JPQL 페치 조인 : 현실적인 대안이지만 화면에 맞춘 레포지터리 메서드가 무분별하게 증가할 수 있음
	- 강제로 초기화
		- 서비스 계층과 프레젠테이션 계층 사이에 프록시 초기화 역할 필요
		-> FACADE 계층 추가
- OSIV를 사용하여 엔티티를 영속상태로 유지

### FACADE 계층 추가
프레젠테이션 계층과 서비스 계층 사이에서 뷰를 위한 프록시 초기화를 담당

- 프레젠테이션 계층과 도메인 모델 계층과의 논리적 의존성 분리
- 프레젠테이션 계층에서 필요한 프록시 계층 초기화
- 서비스 계층을 호출하여 비즈니스 로직 실행
- 리포지터리를 직접 호출하여 뷰가 요구하는 엔티티를 찾음

## OSIV(Open Session In View)
영속성 컨텍스트를 뷰까지 열어두는 것 -> 뷰에서도 지연 로딩 사용 가능

### 이전 OSIV : 요청 당 트랜잭션
동작원리
필터나 인터셉터에서 트랜잭션을 시작하고 요청이 끝날때 트랜잭션을 끝냄

문제점
프레젠테이션 계층이 엔티티를 변경할 수 있게 됨
렌더링하기 위해 변경했는데 영속성 컨텍스트가 플러시 되면서 DB에 반영됨

프레젠테이션 계층의 엔티티 수정을 막는 방법
- 엔티티를 읽기 전용 인터페이스로 제공
엔티티가 View 인터페이스를 구현하도록 하여 수정할 수 없는 View 인터페이스를 넘겨줌
- 엔티티 레핑
엔티티를 감싼 객체를 만들고 프레젠테이션 계층에 반환
- DTO만 반환
엔티티 대신 단순한 데이터 전달 객체인 DTO를 생성해서 반환
OSIV의 장점을 살릴 수 없음

### 스프링 OSIV : 비즈니스 계층 트랜잭션
스프링 프레임워크가 제공하는 OSIV 클래스 중 선택하여 사용
- 하이버네이트 OSIV 서블릿 필터
- 하이버네이트 OSIV 스프링 인터셉터
- JPA OEIV 서블릿 필터
- JPA OEIV 스프링 인터셉터

동작원리 
1. 클라이언트 요청을 받게되면 영속성 컨텍스트를 생성
2. 서비스 계층에서 트랜잭션이 시작되면 앞서 생성된 영속성 컨텍스트에 트랜잭션을 시작
3. 비즈니스 로직이 실행되고 트랜잭션이 커밋되면 영속성 컨텍스트를 플러시
4. 컨트롤러와 뷰까지는 영속성 컨텍스트가 유지 -> 엔티티는 영속 상태 유지
5. 서블릿 필터, 스프링 인터셉터로 요청이 돌아오면 영속성 컨텍스트 종료 (플러시 X)

트랜잭션 없이 읽기(Nontransactional reads)
트랜잭션 없이 엔티티를 변경하지 않고 단순히 조회만 하는 것
- 영속성 컨텍스트가 트랜잭션 범위 밖에서도 엔티티를 조회
- 영속성 컨텍스트는 트랜잭션 범위 안에서만 엔티티를 수정

주의사항
프렌젠테이션 계층에서 엔티티를 수정한 뒤 요청이 종료되면 괜찮지만, 그 뒤에 트랜잭션을 시작하고 커밋되면 수정된 엔티티가 반영됨

단점
같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있음(15.1.4)
프레젠테이션 계층에서 수정 후 비즈니스 로직 수행시 엔티티가 수정될 수 있음
프레젠테이션 계층에서 지연 로딩에 의한 SQL 실행 (성능 확인 필요)



## 프록시 심화 주제
### 영속성 컨텍스트와 프록시

### 프록시 동등성 비교
IDE에서 generate해주는 equals를 사용하여 프록시와 원본 엔티티를 비교하면 문제가 발생
type 체크에서 걸리게 됨 (Member$proxy.class != Member.class)
getClass()가 아닌 instanceof 로 equals를 정의해야 함



### 상속관계와 프록시
프록시를 부모 타입으로 조회하면 부모 타입을 기반으로 프록시를 생성하게 됨
-> instanceof 연산 사용 불가, 하위 타입으로 다운 캐스팅 불가






