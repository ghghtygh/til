# 단위 테스트

# 단위 테스트

### 단위 테스트의 목표
- 소프트웨어 프로젝트의 지속 가능한 성장을 가능하게 하는 것
테스트가 없는 코드는 개발을 빠르게 시작할 수는 있지만 프로젝트가 진행됨에 따라 개발속도가 현저히 느려짐
(= 소프트웨어 엔트로피)

- 테스트 코드도 애플리케이션의 정확성을 보장하는 코드베이스의 일부
가능한 적은 코드(최소 유지비)로 문제를 해결해야 하며, 리팩토링 또한 필요

- 좋은 테스트와 좋지 않은 테스트의 구분 필요
대부분의 애플리케이션의 가장 중요한 부분은 비즈니스 로직(도메인 모델)이며, 초점이 해당 부분에 머물러 있어야 함


### 커버리지 지표
테스트 스위트가 소스 코드를 얼마나 실행하는지를 백분율로 나타낸 것

#### 코드 커버리지(code coverage, test coverage)

테스트 스위트가 실행한 코드 라인 수와 제품 코드베이스의 전체 라인 수의 비율
 
#### 분기 커버리지(branch coverage)

원시 코드 라인 수 보다는 if, switch 문과 같은 제어 구조에 중점을 둠 

테스트 스위트가 수행하는 코드 분기 수와 제품 인드베이스의 전체 분기 수의 비율

#### 커버리지 지표의 문제
- 테스트 대상 시스템의 모든 가능한 결과의 검증이 보장되지 않음
- 외부 라이브러리의 코드 경로를 고려할 수 없음

### 단위 테스트란
작은 단위의 코드 조각을 검증하고, 빠르게 수행되며, 격리된 방식으로 처리하는 자동화된 테스트

여기서 격리된 방식에 대한 견해가 갈림

1. 런던파
하나의 클래스가 다른 클래스에 의존할 때 모든 의존성을 테스트 대역으로 대체
- 한 번에 한 클래스만을 확인 -> 서로 연결된 클래스 그래프가 커져도 테스트하기 쉬움
- 테스트 실패시 어떤 기능이 실패했는지 파악 용이 

2. 고전파
단위가 아닌 단위 테스트 자체를 서로 격리된 상태로 실행(공유 의존성만을 테스트 대역으로 대체)
- 코드 단위의 테스트인 런던파와 달리 동작 단위의 단위 테스트 가능

### 단위 테스트 구성
- AAA 패턴(3A 패턴)  사용 
(Given-When-Then 패턴과 테스트 구성 동일)
각 테스트를 준비, 실행, 검증이라는 세 부분으로 나눔
준비 구절 - SUT와 해당 의존성을 원하는 상태로 만듬
실행 구절 - SUT에서 메서드 호출, 의존성 전달, 출력 값 캡처
검증 구절 - 반환 값, SUT 최종 상태, 호출 메서드 등으로 검증

- 여러 개의 준비, 실행, 검증 구절 X
한 번에 너무 많은 것을 검증하고 있는 것이므로 테스트를 나누어 작성

- 테스트 내 if 문 피하기 
테스트 코드에 분기가 있어 얻는 이점은 없음
안티 패턴이므로 여러 테스트로 나누어 작성

- 각 구절의 크기
일반적으로 준비구절이 가장 큼
너무 큰 경우에는 오브젝트 마더나 테스트 데이터 빌더 패턴을 이용

실행 구절이 두 줄 이상인 경우 문제가 있을 수 있으므로 주의 (캡슐화가 깨진 상황 등)

각 테스트가 하나의 검증을 갖으며 그렇게 하기 위한 가장 작은 코드여야 하지만, 작다는 것은 동작의 단위이지 코드의 단위가 아님
그래도 너무 검증 구절이 큰 것은 추상화가 누락되었을 수 있음
SUT 반환한 객체의 모든 속성을 일일이 비교하는 것보다 클래스 내에서 적절한 동등 멤버를 정의하는 편이 좋음

- 테스트 간 높은 결합도는 안티 패턴
테스트 클래스에 공유 상태를 둔다면 준비 로직을 수정했을 때 클래스의 모든 테스트에 영향을 줄 수 있음

- 비공개 팩토리 메서드로 테스트 픽스처를 재사용
생성자로 준비 코드를 추출한다면 테스트 가독성을 떨어뜨림

- 단위 테스트 명명법
테스트대상메서드_시나리오_예상결과

- 매개변수화된 테스트를 위한 데이터 생성
```
public static List<object[]> Data() {
	return new List<object[]> {
		new object[] {...}
		...
	};
}
```


- 검증문 라이브러리를 사용하여 테스트 가독성 향상
Assertions 라이브러리 등을 이용하여 검증문을 패턴화하여 가독성을 향상 시킬 수 있음 


